### 406.根据身高重建队列

---

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例
```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```
---

#### 贪心

首先，读懂题目的意思，到底要输出什么

```
 {"person":(h,k).....}
其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数
排序这个字典,使之位置符合h,k
```

先对输入数组排序，h升序，k降序，从头循环遍历，当前这个人就是剩下未安排的人中最矮的人，他的k值就代表他**在剩余空位的索引**，如果有多个人高度相同，要按照k值从大到小领取索引值，示例：

```
[ 0, 1, 2, 3, 4, 5 ] [ 4, 4 ] 4
[ 0, 1, 2, 3, 5 ]    [ 5, 2 ] 2
[ 0, 1, 3, 5 ]       [ 5, 0 ] 0
[ 1, 3, 5 ]          [ 6, 1 ] 3
[ 1, 5 ]             [ 7, 1 ] 5
[ 1 ]                [ 7, 0 ] 1
[ [ 5, 0 ], [ 7, 0 ], [ 5, 2 ], [ 6, 1 ], [ 4, 4 ], [ 7, 1 ] ]
```
看代码怎么写的，目前只想到这样处理，应该有更好的方法

``` js
var reconstructQueue = function(people) {
  const res = []
  let len = people.length
  const flag = Array(len).fill(0).map((item, index) => index)
  people.sort((a, b) => {
    if (a[0] === b[0]) return b[1] - a[1]
    else return a[0] - b[0]
  })
  for (let item of people) {
    let k = item[1]
    let index = flag[k]
    flag.splice(k, 1)
    res[index] = item
  }
  return res
};
```
