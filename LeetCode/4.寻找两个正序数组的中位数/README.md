### 4.寻找两个正序数组的中位数

---

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

示例 2:
```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

---

#### 思路

* 首先，这道题给出了复杂度的限制，所以我们首先想到只能用二分法，才可能满足要求，这道题比较复杂

* 为简化程序，对奇偶区别用了个小技巧统一处理

* 定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素

1. 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置

2. 然后来处理一些边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了

3. 还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了

4. 难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，

5. 对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。

6. 赋予最大值的意思只是说如果第一个数组的K/2不存在，则说明这个数组的长度小于K/2，那么另外一个数组的前K/2个我们是肯定不要的。给你举个例子，加入第一个数组长度是2，第二个数组长度是12，则K为7，K/2为3，因为第一个数组长度小于3，则无法判断中位数是否在其中，而第二个数组的前3个肯定不是中位数！故当K/2不存在时，将其置为整数型最大值，这样就可以继续下一次循环。

7. 如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。

8. 有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。

9. 最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可

``` js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  let m = nums1.length
  let n = nums2.length 
  //解决奇偶区别，统一处理
  //left和right是第几个数，不是下标值
  let left = Math.floor((m+n+1)/2)
  let right = Math.floor((m+n+2)/2)
  return (getK(nums1, 0, nums2, 0, left) + getK(nums1, 0, nums2, 0, right))/2
};

function getK(nums1, i, nums2, j, k) {
  //nums1或者nums2为空数组
  //或者说某一个数组已经全部淘汰了
  //题目里说了，不会同时为空
  if (i >= nums1.length) return nums2[j + k - 1]
  if (j >= nums2.length) return nums1[i + k - 1]
  //k=1，取小的那个
  if (k === 1) return Math.min(nums1[i], nums2[j])

  let hk = Math.floor(k / 2)
  let mid1 = (i + hk - 1 < nums1.length) ? nums1[i + hk - 1] : Number.MAX_VALUE
  let mid2 = (j + hk - 1 < nums2.length) ? nums2[j + hk - 1] : Number.MAX_VALUE
  //如果mid1<mid2，说明mid1前面的i+hk个数字都是无用的
  //k要去掉已经淘汰了的k/2个数字
  if (mid1 < mid2) {
    return getK(nums1, i + hk, nums2, j, k - hk)
  } else {
    return getK(nums1, i, nums2, j + hk, k - hk)
  }
}
```
