### 32.最长有效括号

---

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```
示例 2:
```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```
---

#### 思路

利用栈结构

这里栈结构的处理比较巧妙

1. 始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标

2. 对于遇到的每个 '(' ，我们将它的下标放入栈中

3. 对于遇到的每个 ')' ，先弹出栈顶元素表示匹配了当前右括号

4. 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」

5. 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

6. 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，在一开始的时候往栈中放入一个值为 −1 的元素

``` js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  //初始填充一个-1
  let stack = [-1]
  let max = 0
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      stack.push(i)
    } else {
      //把栈顶弹出
      //肯定有东西弹，因为上一次一定压入了东西
      stack.pop()
      if (stack.length === 0) {
        //压入i方便下一次的长度计算，即提供新一轮的起始位置
        stack.push(i)
      } else {
        max = Math.max(max, i - stack[stack.length - 1])
      }
    }
  }
  return max
};
```
