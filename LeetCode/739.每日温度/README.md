### 739.每日温度

---

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

---

#### 思路

* 单调栈解法

1. 当前元素关注的是它右边的元素

2. **选择从右开始遍历**，需要考察的右边元素由少到多

3. 单调递减栈：从栈底到栈顶递减，栈顶小

* 空间换时间

1. 遍历一次数组是少不了的，关键是每个元素寻找目标元素时做了很多重复的遍历

2. 用一个栈结构去**存储右边的项的索引值**，将无需重复比较的元素从该数据结构中剔除，且不会再进来了，避免重复遍历

* 什么剔除，什么留下

1. T[i] 目标是找到第一个大项，小项被 pass 掉，该被剔除

2. 因为比 T[i]还小的元素，肯定不会是 T[i-1] 想找的大项

3. 大项留下，T[i] 也进入到这个栈中，供 T[i-1]寻找

* 具体操作

1. 如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小，停止出栈

2. 此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离

3. 当前项入栈

* 什么时候用单调栈

1. 通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素

2. 要求 O(n) 的时间复杂度


``` js
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function(T) {
  const res = Array(T.length).fill(0)
  const stack = []
  for (let i = T.length - 1; i >= 0; i--) {
    while (stack.length && T[i] >= T[stack[stack.length - 1]]) {
      stack.pop()
    }
    if (stack.length) {
      res[i] = stack[stack.length - 1] - i
    }
    stack.push(i)
  }
  return res
};
```
